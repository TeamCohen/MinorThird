package LBJ2.nlp;


/**
  * This class implements a classifier that takes a {@link Word} as input and
  * generates features representing the forms of the words in a [-2, +2]
  * window around the input word.  The generated features consist of the
  * {@link Word#form} of the input word as well as the forms of the two words
  * before the input word in the sentence and the forms of the two words after
  * the input word in the sentence.  If any of those words do not exist, the
  * corresponding feature isn't generated.
  *
  * <p> This class's implementation was automatically generated by the LBJ
  * compiler.
  *
  * @author Nick Rizzolo
 **/
discrete% Forms(Word word) <-
{
  int i;
  Word w = word, last = word;
  for (i = 0; i <= 2 && last != null; ++i) last = (Word) last.next;
  for (i = 0; i > -2 && w.previous != null; --i) w = (Word) w.previous;

  for (; w != last; w = (Word) w.next) sense i++ : w.form;
}

/**
  * This class implements a classifier that takes a {@link Word} as input and
  * generates Boolean features representing the capitalizations of the words
  * in a [-2, +2] window around the input word.  The generated features
  * consist of the capitalization (as read from {@link Word#capitalized}) of
  * the input word as well as the capitalizations of the two words before the
  * input word in the sentence and the capitalizations of the two words after
  * the input word in the sentence.  If any of those words do not exist, the
  * corresponding feature isn't generated.
  *
  * <p> This class's implementation was automatically generated by the LBJ
  * compiler.
  *
  * @author Nick Rizzolo
 **/
discrete{false, true}% Capitalization(Word word) <-
{
  int i;
  Word w = word, last = word;
  for (i = 0; i <= 2 && last != null; ++i) last = (Word) last.next;
  for (i = 0; i > -2 && w.previous != null; --i) w = (Word) w.previous;

  for (; w != last; w = (Word) w.next) sense i++ : w.capitalized;
}

/**
  * This class implements a classifier that takes a {@link Word} as input and
  * generates Boolean features representing interesting information about the
  * forms of the words in a [-2, +2] window around the input word.  The
  * generated features include one that indicates if the entire input word
  * consists only of capital letters, one that indicates if the entire input
  * word consists only of digits, and one that indicates if the entire input
  * word consists only of non-letters.  The same features are also produced
  * for the two words before and after the input word.  If any of those words
  * do not exist, the corresponding features aren't generated.
  *
  * <p> This class's implementation was automatically generated by the LBJ
  * compiler.
  *
  * @author Nick Rizzolo
 **/
discrete{false, true}% WordTypeInformation(Word word) <-
{
  int i;
  Word w = word, last = word;
  for (i = 0; i <= 2 && last != null; ++i) last = (Word) last.next;
  for (i = 0; i > -2 && w.previous != null; --i) w = (Word) w.previous;

  for (; w != last; w = (Word) w.next, ++i)
  {
    boolean allCapitalized = true, allDigits = true, allNonLetters = true;

    for (int j = 0; j < w.form.length(); ++j)
    {
      allCapitalized &= Character.isUpperCase(w.form.charAt(j));
      allDigits &= Character.isDigit(w.form.charAt(j));
      allNonLetters &= !Character.isLetter(w.form.charAt(j));
    }

    sense "c" + i : allCapitalized;
    sense "d" + i : allDigits;
    sense "p" + i : allNonLetters;
  }
}

/**
  * This class implements a classifier that takes a {@link Word} as input and
  * generates features representing the prefixes and suffixes of the input
  * word.  The generated features include prefixes of length 3 and 4 and
  * suffixes of lengths 1 through 4 of the input word only.  If any of those
  * words do not exist, the corresponding features aren't generated.
  *
  * <p> This class's implementation was automatically generated by the LBJ
  * compiler.
  *
  * @author Nick Rizzolo
 **/
discrete% Affixes(Word word) <-
{
  int N = word.form.length();
  for (int i = 3; i <= 4; ++i)
    if (word.form.length() > i) sense "p|" : word.form.substring(0, i);
  for (int i = 1; i <= 4; ++i)
    if (word.form.length() > i) sense "s|" : word.form.substring(N - i);
}

